\documentclass[12pt,a4paper]{article}
\usepackage[a4paper,margin=2cm]{geometry}

\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[kerning=true]{microtype}
\usepackage{lmodern}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{float}

\usepackage{parskip}

\usepackage{hyperref}
\usepackage{cleveref}

\makeatletter

\title{\vspace{-5ex} \textbf{Static Analyzer Project}}
\author{Matthieu Boyer\and Antoine Groudiev}
\date{\vspace{-1ex}Last updated \today}

\begin{document}
\maketitle

\section*{Introduction}
This is the static analyzer project of Antoine Groudiev and Matthieu Boyer, for the class \emph{Semantics and application to verfication}. It implements the base domains, that is the constant, sign, interval, congruence domains, the reduced product between the interval and the congruence domains ; furthermore, support for the Karrâ€™s linear equality analysis and Backward analysis have been added as extensions.

The provided analyzer should pass every single test included with the project. Specialized tests for each domain and feature have been added.

\section{Iterator}
As recommended, the iterator (in the file \texttt{iterator.ml}) implements a classic worklist algorithm. The Hashtbl \texttt{environment} maintains a map from nodes to abstract values.

\section{Domains}
\subsection{Value Domain to Domain}
A \texttt{VALUE\_DOMAIN} is transformed into a \texttt{DOMAIN} using the \texttt{Domain} functor in \texttt{domain.ml}. It abstracts a set of mappings from variables to integers, abstracting sets of integers with the given \texttt{VALUE\_DOMAIN}.

\subsection{Constant domain}
The constant domain abstracts a set of integers as:
\begin{center}
    \texttt{type t = | Top | Bot | Int of Z.t}
\end{center}
In most cases, operations such as \texttt{widen}, \texttt{meet} and \texttt{join} do not convey much information. Similarly, any non-trivial \texttt{rand} is abstracted as \texttt{Top}.

The functions \texttt{binary} and \texttt{bwd\_binary} are slightly more complicated. For \texttt{binary}, multiplication with \texttt{Int Z.zero} is guaranteed to result in \texttt{Int Z.zero}. Values $\bot$ and $\top$ cases are absorbant. Finally, we can compute the operation if the value of both operands is known; in case of division by zero, the result is $\bot$, which will notably cause future assertion to pass, as seen in the example \texttt{constant/constant\_div\_zero.c}. For \texttt{bwd\_binary}, the cases of $+$, $-$, $\times$ are easy to handle since these operators are invertible. The case of division and modulo is harder, since the special case of zero needs to be extracted.

\subsection{Sign domain}
We chose the following representation for the sign domain elements:
\begin{center}
    \texttt{type t = | Bot | Top | Pos | Neg | Null}
\end{center}
A more complicated sign latice could have been chosen, separating for instance positive values into stricly positive, and positive or null.

Pretty much every function is straighforward. Division can zero can still be detected and abstracted as $\bot$, but there is no added difficulty compared to the constant domain.

\subsection{Interval domain}
To represent an interval, a bound element has been introduced:
\begin{center}
    \texttt{type bound = | MinusInf | Finite of Z.t | PlusInf}
\end{center}
which can later be used in the definition of an abstract type:
\begin{center}
    \texttt{type t  = | Bot | Top | Interval of bound * bound}
\end{center}
Firstly, I later realized that I could have abstracted \texttt{Top} as \texttt{Interval (MinusInf, PlusInf)}, which would have reduced the length of the code. Nevertheless, $\top$ is in general fairly easy to handle, so it introduced no fundamental complexity.

Operations on \texttt{bound} have been introduced, to handle infinite cases. Note that in practice, for an analyzer, cases such as $+\infty - (+\infty)$ never happen, because substractions are only called with one left and one right bound.
A function \texttt{bottomize\_if\_necessary} is used to transform \texttt{Interval} into \texttt{Bot} when the bounds are inverted.

For \texttt{binary}, only multiplication and division are tricky to handle. The main idea is to enumerate all possible cases and to take the most general one. Similarly, I found \texttt{bwd\_binary} extremly difficult to handle in the case of multiplication. Cases where the interval contains zero need to be taken care of, we have to be careful to round intervals -- otherwise multiple tests do not pass\dots It was not fun to code, and even less to debug.

\subsection{Congruence domain}
For this domain, a set is either of the form $\varnothing=\bot$ or $a\mathbb{Z}+b$. This is classically represented by:
\begin{center}
    \texttt{type t = | Bot | Modulo of Z.t * Z.t}
\end{center}
Note that $\top=\mathbb{Z}=1\times\mathbb{Z}+0$, and that $\{b\}=0\times\mathbb{Z}+b$.

Most operations are easy to handle since little information can be deduced. This can be seen, for example, in \texttt{compare}, which results most of the time in $(\bot, \bot)$. Only the \texttt{meet} and \texttt{join} is interesting since one can sometimes use rafinments such as GCD to give a precise abstraction.

\subsection{Reduced product}

\subsection{Karr's linear equality}

\section{Backward analysis}

\end{document}